#include <iostream> // Подключаем библиотеку для ввода-вывода
#include <vector> // Подключаем библиотеку для использования векторов
#include <deque> // Подключаем библиотеку для использования дека
#include <list> // Подключаем библиотеку для использования списков
#include <fstream> // Подключаем библиотеку для работы с файлами
#include <iterator> // Подключаем библиотеку для работы с итераторами
#include <algorithm> // Подключаем библиотеку для алгоритмов (sort, search и др.)
#include <string> // Подключаем библиотеку для работы со строками
#include <limits> // Подключаем библиотеку для работы с пределами типов

// Объявляем функции, представляющие задачи
void zadacha1();
void zadacha2();
void zadacha3();
void zadacha4();
void zadacha5();
void zadacha6();

// Функция для отображения меню и обработки выбора пользователя
void menu() {
    int choice; // Переменная для хранения выбора пользователя

    // Цикл, который продолжается, пока пользователь не введет 0 (выход)
    do {
        std::cout << "Выберите задачу (1-6) или 0 для выхода:\n";
        std::cout << "1 - Задача 1\n";
        std::cout << "2 - Задача 2\n";
        std::cout << "3 - Задача 3\n";
        std::cout << "4 - Задача 4\n";
        std::cout << "5 - Задача 5\n";
        std::cout << "6 - Задача \n";
        std::cout << "Ваш выбор: ";
        std::cin >> choice; 

        // В зависимости от выбора пользователя вызываем соответствующую задачу
        switch (choice) {
            case 1: zadacha1(); break;
            case 2: zadacha2(); break;
            case 3: zadacha3(); break;
            case 4: zadacha4(); break;
            case 5: zadacha5(); break;
            case 6: zadacha6(); break;
            case 0: break; 
            default: std::cout << "Неверный выбор. Пожалуйста, попробуйте снова.\n"; // Обработка неверного ввода
        }
        
    } while (choice != 0); // Повторяем до тех пор, пока не будет введено 0
}

// Первая задача: чтение чисел из файла и вывод их на экран
// Дан текстовый файл с именем name, содержащий строковые представления целых чисел.
//Заполнить вектор V числами из исходного файла и вывести элементы вектора в исходном
//порядке.
void zadacha1() {
    std::string filename; // Переменная для имени файла
    std::cout << "Введите имя файла: "; // Запрашиваем имя файла
    std::cin >> filename; // Считываем имя файла

    std::ifstream file(filename); // Открываем файл для чтения
    if (!file.is_open()) { // Проверяем, удалось ли открыть файл
        std::cerr << "Ошибка открытия файла!\n"; // Ошибка, если файл не удалось открыть
        return; // Завершаем функцию
    }

    std::vector<int> V; // Создаем вектор для хранения чисел
    int num; // Переменная для считывания числа
    while (file >> num) { // Читаем числа из файла
        V.push_back(num); // Добавляем числа во вектор
    }
    file.close(); // Закрываем файл

    std::cout << "Элементы вектора:\n"; // Выводим сообщение
    for (int n : V) { // Перебираем элементы вектора
        std::cout << n << " "; // Выводим каждый элемент
    }
    std::cout << std::endl; // Завершаем строку
}

// Вторая задача(6): модификация вектора и дека
void zadacha2() {
    std::vector<int> V; // Вектор для хранения данных
    std::deque<int> D; // Дек для хранения данных

    int value; // Переменная для считывания значения
    std::cout << "Введите элементы вектора V (введите -1 для завершения ввода): \n";
    while (std::cin >> value && value != -1) { // Считываем вектор до ввода -1
        V.push_back(value); // Добавляем значение в вектор
    }

    std::cout << "Введите элементы дека D (введите -1 для завершения ввода): \n";
    while (std::cin >> value && value != -1) { // Считываем дек до ввода -1
        D.push_back(value); // Добавляем значение в дек
    }

    // Добавляем первую половину элементов дека в конец вектора
    size_t half_d_size = D.size() / 2; // Вычисляем половину размера дека
    V.insert(V.end(), D.begin(), D.begin() + half_d_size); // Вставляем первую половину дека в конец вектора

    // Добавляем вторую половину вектора в начало дека в обратном порядке
    D.insert(D.begin(), V.rbegin(), V.rbegin() + (V.size() / 2)); // Вставляем половину вектора в начало дека

    std::cout << "Вектор V после изменений:\n"; // Выводим сообщение
    for (int n : V) { // Перебираем и выводим элементы вектора
        std::cout << n << " "; // Выводим каждый элемент
    }
    std::cout << "\nДек D после изменений:\n"; // Выводим сообщение
    for (int n : D) { // Перебираем и выводим элементы дека
        std::cout << n << " "; // Выводим каждый элемент
    }
    std::cout << std::endl; // Завершаем строку
}

// Третья задача(8): удаление элементов с нечетными позициями из вектора
// Дан вектор V. Удалить все элементы исходного вектора с нечетными порядковыми номерами
//(считая, что начальный элемент вектора имеет порядковый номер 1). Использовать функциючлен erase в циклес параметром-итератором
void zadacha3() {
    std::vector<int> V; // Создаем вектор для хранения чисел
    int value; // Переменная для считывания значения

    std::cout << "Введите элементы вектора V (введите -1 для завершения ввода): \n";
    while (std::cin >> value && value != -1) { // Считываем элементы до ввода -1
        V.push_back(value); // Добавляем значение в вектор
    }

    std::cout << "Исходный вектор V:\n"; // Выводим сообщение
    for (int n : V) { // Перебираем элементы вектора
        std::cout << n << " "; // Выводим каждый элемент
    }
    std::cout << std::endl; // Завершаем строку

    // Удаляем элементы с нечетными порядковыми номерами
    auto it = V.begin(); // Создаем итератор для вектора
    while (it != V.end()) { // Пока итератор не дошел до конца
        it = V.erase(it); // Удаляем текущий элемент и получаем итератор на следующий
        if (it != V.end()) ++it; // Если не достигли конца, перемещаем итератор на следующий
    }

    std::cout << "Вектор V после удаления:\n"; // Выводим сообщение
    for (int n : V) { // Перебираем и выводим оставшиеся элементы вектора
        std::cout << n << " "; // Выводим каждый элемент
    }
    std::cout << std::endl; // Завершаем строку
}

// Четвертая задача(2): чтение чисел из файла и вывод чисел с нечетными номерами
// Дан текстовый файл с именем name, содержащий строковые представления целых чисел.
// Вывести числа из исходного файла с нечетными порядковыми номерами
void zadacha4() {
    std::string filename; // Переменная для имени файла
    std::cout << "Введите имя файла: "; // Запрашиваем имя файла
    std::cin >> filename; // Считываем имя файла

    std::ifstream file(filename); // Открываем файл для чтения
    if (!file.is_open()) { // Проверяем, удалось ли открыть файл
        std::cerr << "Ошибка открытия файла!\n"; // Ошибка, если файл не удалось открыть
        return; // Завершаем функцию
    }

    // Инициализируем итераторы для чтения чисел из файла
    std::istream_iterator<int> start(file), end; // Итераторы для начала и конца
    std::vector<int> V(start, end); // Создаем вектор из чисел файла

    std::cout << "Числа с нечетными порядковыми номерами:\n"; // Выводим сообщение
    for (size_t i = 0; i < V.size(); ++i) { // Перебираем все индексы вектора
        if (i % 2 == 0) { // Проверяем, является ли индекс четным (нечетные номера в массиве)
            std::cout << V[i] << " "; // Если да, выводим элемент
        }
    }
    std::cout << std::endl; // Завершаем строку
}

// Пятая задача(9): модификация вектора с учетом K
// Продублировать в векторе V первый набор из K подряд
// расположенных положительных чисел, вставив после этого набора его копию
void zadacha5() {
    int K; // Переменная для хранения значения K
    std::cout << "Введите K (больше 0): "; // Запрашиваем K
    while (!(std::cin >> K) || K <= 0) { // Проверяем корректность ввода
        std::cout << "Некорректный ввод. Попробуйте снова: "; // Сообщение об ошибке
        std::cin.clear(); // Очищаем состояние потока
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Игнорируем оставшиеся символы
    }

    std::vector<int> V; // Создаем вектор для хранения чисел
    int value; // Переменная для считывания значения

    std::cout << "Введите элементы вектора V (введите -1 для завершения ввода): \n";
    while (std::cin >> value && value != -1) { // Считываем элементы до ввода -1
        V.push_back(value); // Добавляем значение в вектор
    }

    // Ищем первый набор из K подряд положительных чисел
    auto it = std::search_n(V.begin(), V.end(), K, 1, [](int n, int) { return n > 0; }); // Ищем K последовательных положительных чисел

    if (it != V.end()) { // Если нашли такие числа
        std::vector<int> new_elements(it, it + K); // Создаем новый вектор из найденных элементов
        V.insert(it + K, new_elements.begin(), new_elements.end()); // Вставляем новые элементы в вектор после найденных
    }

    std::cout << "Вектор V после модификаций:\n"; // Выводим сообщение
    for (int n : V) { // Перебираем и выводим оставшиеся элементы вектора
        std::cout << n << " "; // Выводим каждый элемент
    }
    std::cout << std::endl; // Завершаем строку
}

// Шестая задача(9): модификация двух списков
// В каждом списке продублировать первую половину, добавив ее элементы в конец списка в обратном
// порядке
void zadacha6() {
    std::list<int> L1, L2; // Создаем два списка
    int value; // Переменная для считывания значения

    std::cout << "Введите элементы списка L1 (введите -1 для завершения ввода): \n";
    while (std::cin >> value && value != -1) { // Считываем элементы до ввода -1
        L1.push_back(value); // Добавляем значение в L1
    }

    std::cout << "Введите элементы списка L2 (введите -1 для завершения ввода): \n";
    while (std::cin >> value && value != -1) { // Считываем элементы до ввода -1
        L2.push_back(value); // Добавляем значение в L2
    }

    // Задача для первого списка
    int half_size_L1 = L1.size() / 2; // Вычисляем половину размера первого списка
    std::list<int> first_half_L1(L1.begin(), std::next(L1.begin(), half_size_L1)); // Создаем новый список из первой половины L1
    std::reverse_copy(first_half_L1.begin(), first_half_L1.end(), std::back_inserter(L1)); // Реверсируем и добавляем первую половину в конец L1

    std::cout << "Список L1 после изменений:\n"; // Выводим сообщение
    for (int n : L1) { // Перебираем и выводим элементы списка L1
        std::cout << n << " "; // Выводим каждый элемент
    }
    std::cout << std::endl; // Завершаем строку

    // Задача для второго списка
    int half_size_L2 = L2.size() / 2; // Вычисляем половину размера второго списка
    auto it_half_L2 = std::next(L2.begin(), half_size_L2); // Получаем итератор на середину второго списка
    // Добавляем первую половину второго списка в конец, затем добавляем вторую половину
    L2.insert(L2.end(), std::make_move_iterator(L2.begin()), std::make_move_iterator(it_half_L2));
    L2.insert(L2.end(), std::make_move_iterator(--it_half_L2), std::make_move_iterator(L2.begin()));

    std::cout << "Список L2 после изменений:\n"; // Выводим сообщение
    for (int n : L2) { // Перебираем и выводим элементы списка L2
        std::cout << n << " "; // Выводим каждый элемент
    }
    std::cout << std::endl; // Завершаем строку
}

// Основная функция программы
int main() {
    setlocale(LC_ALL, "Russian"); // Устанавливаем локализацию для русского языка
    menu(); // Вызываем функцию меню
    return 0; // Возвращаем 0, указывая на успешное завершение программы
}
